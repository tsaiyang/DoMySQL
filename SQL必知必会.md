### SELECT查询时的两个顺序
1. 关键字的顺序是不能颠倒的：SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...
2. SELECT 语句的执行顺序：FROM > WHERE > GROUP BY > HAVING > SELECT 的字段 > DISTINCT > ORDER BY > LIMIT

### 对数据库进行调优，都有哪些维度可以进行选择？
1. 选择适合的 DBMS
2. 优化表设计：一般情况下遵循三范式，如果分析查询应用比较多，则采用反范式进行优化，表字段数据类型要选合适，不要太过冗余
3. 优化查询：索引及语句优化
4. redis或者memcache缓存
5. 库级优化：什么情况下做垂直切分，什么情况下做水平切分呢？（1）如果数据库中的数据表过多，可以采用垂直分库的方式，将关联的数据表部署在一个数据库上。（2）如果数据表中的列过多，可以采用垂直分表的方式，将数据表分拆成多张，把经常一起使用的列放到同一张表里。（3）如果数据表中的数据达到了亿级以上，可以考虑水平切分，将大的数据表分拆成不同的子表，每张表保持相同的表结构。比如你可以按照年份来划分，把不同年份的数据放到不同的数据表中。2017 年、2018 年和 2019 年的数据就可以分别放到三张数据表中。（4）采用垂直分表的形式，就是将一张数据表分拆成多张表，采用水平拆分的方式，就是将单张数据量大的表按照某个属性维度分成不同的小表。

### 范式设计
1. 原子性，每个字段都是不能再被拆分的
2. 表里的非主属性都要和这个数据表的候选键有完全依赖关系
3. 对任何非主属性都不传递依赖于候选键

### 创建索引有哪些规律？
1. 字段的数值有唯一性的限制，比如用户名
2. 频繁作为 WHERE 查询条件的字段，尤其在数据表大的情况下
3. 需要经常 GROUP BY 和 ORDER BY 的列
4. UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引
5. DISTINCT 字段需要创建索引
6. 做多表 JOIN 连接操作时，创建索引需要注意以下的原则
    1. 首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。
    2. 其次，对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。
    3. 最后，对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。

### 什么情况下索引失效
1. 如果索引进行了表达式计算，则会失效
2. 如果对索引使用函数，也会造成失效
3. 在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。
4. 当我们使用 LIKE 进行模糊查询的时候，前面不能是%
5. 索引列与 NULL 或者 NOT NULL 进行判断的时候也会失效。
6. 我们在使用联合索引的时候要注意最左原则

### 悲观锁和乐观锁
#### 乐观锁
认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者时间戳机制实现。
#### 乐观锁的版本号机制 
在表中设计一个版本字段 version，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行UPDATE ... SET version=version+1 WHERE version=version。此时如果已经有事务对这条数据进行了更改，修改就不会成功。

#### 悲观锁
悲观锁（Pessimistic Locking）也是一种思想，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。

### 定位SQL执行慢
![](慢查询优化流程.png)

### 避免索引失效的原则
1. 全值匹配我最爱
2. 最佳左前缀法则
3. 不在索引列上做任何操作（计算、函数、（自动or手动）类型转换）
4. 存储引擎不能使用索引中范围条件右边的列
5. 尽量使用覆盖索引，减少select
6. mysql中在使用不等于的时候无法使用索引会导致全表扫描
7. is null,is not null也无法使用索引
8. like前面使用通配符会使索引失效
9. 字符串不加单引号会使索引失效
10. 少用or，用它来连接时索引失效
